<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MSK Special Tests — Drag & Match</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0c0f1e; --bg2:#0a0d1a; --card:#171c3a; --border:#2a3160;
    --muted:#9aa4bf; --ink:#eaf0ff; --ok:#33d17a; --bad:#ff6b6b;
    --acc1:#8b7cff; --acc2:#00d1ff; --acc3:#ffc36b;
    --shadow: 0 8px 28px rgba(5,8,28,.35);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%}
  body{
    margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
    background: radial-gradient(1200px 800px at 10% -10%, #12163a 0%, #0c0f1e 45%, #0a0d1a 100%);
    color:var(--ink);
    -webkit-user-select:none; user-select:none;
  }

  .wrap{
    max-width:1200px; margin:0 auto; padding:24px 16px 40px;
    display:flex; flex-direction:column; gap:18px;
  }

  header{
    position:sticky; top:0; z-index:5;
    background:linear-gradient(180deg, rgba(12,15,30,1), rgba(12,15,30,.85), rgba(12,15,30,0));
    backdrop-filter:saturate(1.1) blur(4px);
    padding-bottom:6px;
    display:flex; gap:14px; align-items:flex-start; justify-content:space-between;
  }
  .title h1{
    margin:0; font-size: clamp(22px, 3.5vw, 34px); letter-spacing:.2px;
    background: linear-gradient(90deg,var(--acc1),var(--acc2),var(--acc3));
    -webkit-background-clip:text; background-clip:text; color:transparent;
  }
  .title p{margin:.25rem 0 0; color:var(--muted); font-size:14px}

  .controls{
    display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;
  }
  button{
    appearance:none; border:1px solid var(--border); background:var(--card);
    color:var(--ink); padding:12px 14px; border-radius:12px; font-weight:700;
    cursor:pointer; box-shadow:var(--shadow); transition:transform .06s ease, border-color .2s ease;
    touch-action:manipulation;
  }
  button:hover{ transform:translateY(-1px); border-color:#3b4591; }
  button:active{ transform:translateY(0); }
  .timer{
    display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px;
    border:1px solid var(--border); background:rgba(23,28,58,.6); font-weight:800;
  }

  .grid{
    display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start;
  }

  .column{
    background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
    border:1px solid var(--border);
    border-radius:16px; padding:14px; box-shadow:var(--shadow);
    min-height:420px;
    display:flex; flex-direction:column; gap:12px;
    justify-content:flex-start; align-content:flex-start;
  }
  .column h2{
    margin:4px 4px 6px; font-size:16px; color:var(--muted); font-weight:700; letter-spacing:.3px;
  }

  .bank, .targets{
    display:flex; flex-direction:column; gap:10px;
    justify-content:flex-start; align-content:flex-start; align-items:stretch;
  }

  .card{
    border:1px solid var(--border); background:rgba(23,28,58,.92);
    border-radius:14px; padding:14px 14px; line-height:1.25;
    font-weight:800; user-select:none;
    box-shadow:var(--shadow);
    touch-action:none;           /* enables smooth pointer-drag on mobile */
  }
  .card[draggable="true"]{ cursor:grab; }
  .card.dragging{ opacity:.6; outline:2px dashed #4e59be; }

  .target{
    border:1px dashed #39407a; border-radius:14px; padding:10px; position:relative;
    min-height:64px; display:flex; align-items:center; justify-content:space-between; gap:10px;
    background:rgba(10,13,26,.6);
  }
  .target .label{
    font-weight:800; font-size:15px; color:#cad3f8;
  }
  .slot{
    flex:0 0 auto; min-width:210px; min-height:44px; border:1px solid #39407a; border-radius:12px;
    display:flex; align-items:center; justify-content:center; padding:6px 8px; color:var(--muted);
    background:rgba(19,23,47,.6)
  }
  .slot.filled{ border-style:solid; color:#9fb3ff; font-weight:700; }
  .target.over, .slot.over{ outline:2px dashed #6a74ff; outline-offset:2px }

  .badge{
    font-size:12px; font-weight:800; padding:6px 10px; border-radius:999px; border:1px solid var(--border);
    background:linear-gradient(90deg, rgba(139,124,255,.15), rgba(0,209,255,.15));
    color:#cfd7ff; letter-spacing:.3px; white-space:nowrap;
  }

  .footer{
    display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    color:var(--muted); font-size:13px; padding-top:8px;
  }
  .score{ font-weight:800; color:#cfe6ff }
  .toast{
    position:fixed; inset:auto 16px 16px auto; z-index:50; padding:10px 14px; border-radius:12px;
    border:1px solid var(--border); background:var(--card); color:var(--ink); box-shadow:var(--shadow);
    display:none;
  }
  .toast.show{ display:block; }

  /* Confetti bits */
  .confetti{
    position:fixed; left:0; top:0; width:100%; height:0; overflow:visible; z-index:60; pointer-events:none;
  }
  .confetti i{
    position:absolute; top:-10px; width:8px; height:14px; border-radius:2px;
    background: white; opacity:.9;
    animation: fall 1400ms linear forwards;
  }
  @keyframes fall{
    to{ transform: translateY(110vh) rotate(720deg); opacity:1; }
  }

  /* Mobile polish */
  @media (max-width: 900px){
    .grid{ grid-template-columns: 1fr; }
    .slot{ min-width:unset; width:100%; min-height:48px; }
    .target{ flex-wrap:wrap; gap:8px }
    .title p{ font-size:13px }
    .card{ font-size:15px; padding:16px }
  }

  .drag-ghost{
    position:fixed; left:0; top:0; z-index:9999; pointer-events:none;
    transform:translate(-9999px,-9999px) scale(1.02);
    filter:drop-shadow(0 10px 22px rgba(0,0,0,.45));
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>MSK Special Tests — Drag &amp; Match</h1>
        <p>Drag a test from the left into the matching condition on the right. No hints. No sharing. Just skills.</p>
      </div>
      <div class="controls">
        <button id="shuffleBtn" title="Shuffle bank items">Shuffle</button>
        <button id="resetBtn" title="Reset everything">Reset</button>
        <button id="checkBtn" title="Check your matches">Check answers</button>
        <span class="timer">
          <button id="timerBtn" aria-pressed="false" title="Start/stop 2-minute timer">Start 2:00</button>
          <span id="timerReadout">—:—</span>
        </span>
      </div>
    </header>

    <div class="grid" id="board" aria-live="polite">
      <!-- Bank -->
      <section class="column">
        <h2>Test Bank</h2>
        <div class="bank" id="bank" aria-label="Draggable tests"></div>
      </section>

      <!-- Targets -->
      <section class="column">
        <h2>Match to the Condition</h2>
        <div class="targets" id="targets" aria-label="Drop targets"></div>
      </section>
    </div>

    <div class="footer">
      <div class="badge">No hints • No class sharing</div>
      <div class="score" id="score">0 / 10 correct</div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>
  <div class="confetti" id="confetti"></div>

<script>
(() => {
  // --- Dataset ---
  const PAIRS = [
    { id: "hawkins",   left: "Hawkins–Kennedy",              right: "Subacromial impingement" },
    { id: "emptycan",  left: "Empty Can (Jobe) Test",        right: "Supraspinatus tear/tendinopathy" },
    { id: "appreloc",  left: "Apprehension + Relocation",    right: "Anterior shoulder instability" },
    { id: "speeds",    left: "Speed’s Test",                 right: "Long-head biceps tendinopathy" },
    { id: "finkel",    left: "Finkelstein Test",             right: "De Quervain’s tenosynovitis" },
    { id: "phalen",    left: "Phalen’s Test",                right: "Carpal tunnel syndrome" },
    { id: "lachman",   left: "Lachman Test",                 right: "ACL rupture" },
    { id: "mcmurray",  left: "McMurray Test",                right: "Meniscal tear" },
    { id: "thompson",  left: "Thompson Test",                right: "Achilles tendon rupture" },
    { id: "talar",     left: "Talar Tilt",                   right: "Lateral ankle instability (ATFL/CFL)" },
  ];

  // --- State ---
  let placed = {}; // targetId -> cardId
  let dragData = null;

  // Timer state
  let timerActive = false;
  let timerSecs = 120; // 2:00
  let timerHandle = null;

  // --- Elements ---
  const bankEl    = document.getElementById('bank');
  const targetsEl = document.getElementById('targets');
  const scoreEl   = document.getElementById('score');
  const toastEl   = document.getElementById('toast');
  const confettiEl= document.getElementById('confetti');

  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const checkBtn   = document.getElementById('checkBtn');
  const timerBtn   = document.getElementById('timerBtn');
  const timerReadout = document.getElementById('timerReadout');

  // --- Helpers ---
  const rand = (arr) => arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

  function showToast(msg, ms=1600){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toastEl.classList.remove('show'), ms);
  }

  function mmss(s){
    const m = Math.floor(s/60).toString();
    const ss = (s%60).toString().padStart(2,'0');
    return `${m}:${ss}`;
  }

  function startTimer(){
    if(timerActive) return;
    timerActive = true;
    timerBtn.setAttribute('aria-pressed','true');
    timerBtn.textContent = 'Stop';
    timerReadout.textContent = mmss(timerSecs);
    timerHandle = setInterval(()=>{
      timerSecs--;
      timerReadout.textContent = mmss(Math.max(timerSecs,0));
      if(timerSecs<=0){
        stopTimer();
        showToast('Time! ⏰');
        revealIncorrectFlash();
      }
    },1000);
  }
  function stopTimer(reset=true){
    timerActive = false;
    timerBtn.setAttribute('aria-pressed','false');
    timerBtn.textContent = 'Start 2:00';
    clearInterval(timerHandle);
    timerHandle = null;
    if(reset){
      timerSecs = 120;
      timerReadout.textContent = '—:—';
    }
  }

  function revealIncorrectFlash(){
    document.querySelectorAll('.target').forEach(t => {
      const tId = t.dataset.targetId;
      const ok = placed[tId] === tId;
      t.style.boxShadow = ok ? '0 0 0 2px inset rgba(51,209,122,.75)' : '0 0 0 2px inset rgba(255,107,107,.65)';
      setTimeout(() => t.style.boxShadow = 'none', 900);
    });
  }

  function makeCard(pair){
    const el = document.createElement('div');
    el.className = 'card';
    el.draggable = true;
    el.dataset.cardId = pair.id;
    el.textContent = pair.left;

    // Desktop drag events
    el.addEventListener('dragstart', e => {
      dragData = { type:'card', cardId: pair.id };
      el.classList.add('dragging');
      e.dataTransfer.setData('text/plain', pair.id);
      e.dataTransfer.effectAllowed = 'move';
    });
    el.addEventListener('dragend', () => {
      dragData = null;
      el.classList.remove('dragging');
    });

    // Touch/Pointer drag (mobile)
    enablePointerDrag(el, pair.id);
    return el;
  }

  function makeTarget(pair){
    const target = document.createElement('div');
    target.className = 'target';
    target.dataset.targetId = pair.id;

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = pair.right;

    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.textContent = 'Drop test here';
    slot.dataset.accepts = pair.id;

    // DnD handlers for both target and slot (desktop)
    [target, slot].forEach(el=>{
      el.addEventListener('dragover', e => {
        if(!dragData || dragData.type!=='card') return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        el.classList.add('over');
      });
      el.addEventListener('dragleave', () => el.classList.remove('over'));
      el.addEventListener('drop', e => {
        e.preventDefault();
        el.classList.remove('over');
        const cardId = e.dataTransfer.getData('text/plain') || (dragData && dragData.cardId);
        if(!cardId) return;
        placeCard(cardId, pair.id);
      });
    });

    target.appendChild(label);
    target.appendChild(slot);
    return target;
  }

  function render(){
    bankEl.innerHTML = '';
    targetsEl.innerHTML = '';
    placed = {};

    // Build bank (shuffled on load)
    const shuffled = rand(PAIRS.slice());
    shuffled.forEach(p => bankEl.appendChild(makeCard(p)));

    // Build targets (stable order)
    PAIRS.forEach(p => targetsEl.appendChild(makeTarget(p)));

    updateScore();
  }

  function placeCard(cardId, targetId){
    const cardEl = findCardEl(cardId);
    if(!cardEl) return;

    // Free previous placements of this card
    for (const [tId, cId] of Object.entries(placed)){
      if(cId === cardId){ clearSlot(tId); }
    }
    // If target already filled, return its card to the bank
    if (placed[targetId]) {
      returnCardToBank(placed[targetId]);
    }

    const slot = findSlotEl(targetId);
    slot.textContent = '';
    slot.classList.add('filled');
    slot.appendChild(cardEl);
    placed[targetId] = cardId;
    updateScore();

    // Auto-win check on each placement
    const correct = countCorrect();
    if(correct === PAIRS.length){
      celebrateAndReset();
    }
  }

  function clearSlot(targetId){
    const slot = findSlotEl(targetId);
    if(!slot) return;
    if(slot.firstElementChild){
      bankEl.appendChild(slot.firstElementChild);
    }
    slot.textContent = 'Drop test here';
    slot.classList.remove('filled');
    delete placed[targetId];
  }

  function returnCardToBank(cardId){
    const cardEl = findCardEl(cardId);
    if(!cardEl) return;
    bankEl.appendChild(cardEl);
    for (const [tId, cId] of Object.entries(placed)){
      if(cId === cardId){
        slotReset(tId);
        delete placed[tId];
        break;
      }
    }
    updateScore();
  }

  function slotReset(targetId){
    const slot = findSlotEl(targetId);
    if(slot){
      slot.textContent = 'Drop test here';
      slot.classList.remove('filled');
    }
  }

  function findCardEl(cardId){
    return document.querySelector(`.card[data-card-id="${cardId}"]`);
  }
  function findSlotEl(targetId){
    return document.querySelector(`.target[data-target-id="${targetId}"] .slot`);
  }

  function countCorrect(){
    let correct = 0;
    for (const pair of PAIRS){
      if(placed[pair.id] === pair.id) correct++;
    }
    return correct;
  }

  function updateScore(){
    scoreEl.textContent = `${countCorrect()} / ${PAIRS.length} correct`;
  }

  // --- Controls ---
  shuffleBtn.addEventListener('click', () => {
    Object.keys(placed).forEach(clearSlot);
    const cards = [...bankEl.children];
    const shuffled = rand(cards);
    bankEl.innerHTML = '';
    shuffled.forEach(el => bankEl.appendChild(el));
    showToast('Shuffled the bank.');
  });

  resetBtn.addEventListener('click', () => {
    render();
    showToast('Board reset.');
  });

  checkBtn.addEventListener('click', () => {
    document.querySelectorAll('.target').forEach(t => {
      t.style.boxShadow = 'none';
      const tId = t.dataset.targetId;
      const ok = placed[tId] === tId;
      t.style.boxShadow = ok ? '0 0 0 2px inset rgba(51,209,122,.75)' : '0 0 0 2px inset rgba(255,107,107,.65)';
      setTimeout(() => t.style.boxShadow = 'none', 900);
    });
    const correct = countCorrect();
    showToast(correct === PAIRS.length ? 'Perfect! 🎉' : 'Keep going!');
    if(correct === PAIRS.length) celebrateAndReset();
  });

  timerBtn.addEventListener('click', () => {
    if(!timerActive) startTimer(); else stopTimer();
  });

  // Allow returning a card to the bank by dropping it anywhere in the bank (desktop)
  bankEl.addEventListener('dragover', e => {
    if(!dragData || dragData.type!=='card') return;
    e.preventDefault();
    bankEl.classList.add('over');
  });
  bankEl.addEventListener('dragleave', () => bankEl.classList.remove('over'));
  bankEl.addEventListener('drop', e => {
    e.preventDefault();
    bankEl.classList.remove('over');
    const cardId = e.dataTransfer.getData('text/plain') || (dragData && dragData.cardId);
    if(!cardId) return;
    returnCardToBank(cardId);
  });

  // --- Mobile pointer drag with EDGE SCROLL ---
  function enablePointerDrag(cardEl, cardId){
    let ghost = null;
    let autoScrollDir = 0; // -1 up, +1 down, 0 none
    let autoScrollRAF = null;

    const onPointerDown = (e) => {
      if(e.button !== undefined && e.button !== 0) return;
      cardEl.setPointerCapture?.(e.pointerId);
      e.preventDefault();

      ghost = cardEl.cloneNode(true);
      ghost.classList.add('drag-ghost');
      ghost.style.width = (cardEl.getBoundingClientRect().width) + 'px';
      document.body.appendChild(ghost);

      positionGhost(e.clientX, e.clientY);
      cardEl.classList.add('dragging');
      dragData = { type:'card', cardId };

      startAutoScroll();
    };

    const onPointerMove = (e) => {
      if(!ghost) return;
      positionGhost(e.clientX, e.clientY);

      // Edge scroll thresholds
      const edge = 80;
      if(e.clientY > window.innerHeight - edge) autoScrollDir = +1;
      else if(e.clientY < edge) autoScrollDir = -1;
      else autoScrollDir = 0;

      const dropEl = getDropTargetAt(e.clientX, e.clientY);
      document.querySelectorAll('.target, .slot').forEach(el => el.classList.remove('over'));
      if(dropEl) dropEl.classList.add('over');
    };

    const onPointerUp = (e) => {
      if(!ghost) return;
      const dropEl = getDropTargetAt(e.clientX, e.clientY);
      cleanupDrag();

      if(dropEl){
        const target = dropEl.classList.contains('target') ? dropEl : dropEl.closest('.target');
        if(target && target.dataset.targetId){
          placeCard(cardId, target.dataset.targetId);
          return;
        }
      }
      returnCardToBank(cardId);
    };

    function positionGhost(x,y){
      const offset = 18;
      ghost.style.transform = `translate(${x+8}px, ${y-offset}px)`;
    }

    function getDropTargetAt(x,y){
      const el = document.elementFromPoint(x,y);
      if(!el) return null;
      return el.closest?.('.slot, .target') || null;
    }

    function startAutoScroll(){
      if(autoScrollRAF) return;
      const step = () => {
        if(autoScrollDir !== 0){
          window.scrollBy(0, autoScrollDir * 8); // speed
        }
        autoScrollRAF = requestAnimationFrame(step);
      };
      autoScrollRAF = requestAnimationFrame(step);
    }

    function stopAutoScroll(){
      if(autoScrollRAF){
        cancelAnimationFrame(autoScrollRAF);
        autoScrollRAF = null;
      }
      autoScrollDir = 0;
    }

    function cleanupDrag(){
      stopAutoScroll();
      document.querySelectorAll('.target, .slot').forEach(el => el.classList.remove('over'));
      cardEl.classList.remove('dragging');
      dragData = null;
      if(ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);
      ghost = null;
    }

    cardEl.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointercancel', onPointerUp);
  }

  // --- Celebration + Auto Reset ---
  function celebrateAndReset(){
    // Confetti burst
    burstConfetti(120);
    showToast('Perfect! 🎉 New round in 2s…', 2000);
    // Stop timer but keep readout until reset
    stopTimer(true);
    setTimeout(() => render(), 2000);
  }

  function burstConfetti(n=80){
    // Create bits
    for(let i=0;i<n;i++){
      const bit = document.createElement('i');
      const hue = Math.floor(200 + Math.random()*140); // cool range
      const left = Math.random()*100;
      const delay = Math.random()*80; // ms stagger
      bit.style.left = left + 'vw';
      bit.style.background = `hsl(${hue} 100% 70%)`;
      bit.style.transform = `translateY(-10px) rotate(${Math.random()*360}deg)`;
      bit.style.animationDelay = delay+'ms';
      confettiEl.appendChild(bit);
      setTimeout(()=> bit.remove(), 1600 + delay);
    }
  }

  // Initial render
  render();
})();
</script>
</body>
</html>
